side,file_path,has_no_body,extern_c,source,line_count,line_range
C,E:\rust_projects\c\blazesym\capi\include\blazesym.h,True,True,blaze_symbolizer *blaze_symbolizer_new_opts(const struct blaze_symbolizer_opts *opts);,1,"(1300, 1300)"
Rust,E:\rust_projects\c\blazesym\capi\src\symbolize.rs,False,True,"pub unsafe extern ""C"" fn blaze_symbolizer_new_opts(
    opts: *const blaze_symbolizer_opts,
) -> *mut blaze_symbolizer {
    if !input_zeroed!(opts, blaze_symbolizer_opts) {
        let () = set_last_err(blaze_err::INVALID_INPUT);
        return ptr::null_mut()
    }
    let opts = input_sanitize!(opts, blaze_symbolizer_opts);

    let blaze_symbolizer_opts {
        type_size: _,
        debug_dirs,
        debug_dirs_len: _debug_dirs_len,
        auto_reload,
        code_info,
        inlined_fns,
        demangle,
        reserved: _,
    } = opts;

    let builder = Symbolizer::builder()
        .enable_auto_reload(auto_reload)
        .enable_code_info(code_info)
        .enable_inlined_fns(inlined_fns)
        .enable_demangling(demangle);

    let builder = if debug_dirs.is_null() {
        builder
    } else {
        #[cfg(feature = ""dwarf"")]
        {
            // SAFETY: The caller ensures that the pointer is valid and the count
            //         matches.
            let slice = unsafe { slice_from_user_array(debug_dirs, _debug_dirs_len) };
            let iter = slice.iter().map(|cstr| {
                Path::new(OsStr::from_bytes(
                    // SAFETY: The caller ensures that valid C strings are
                    //         provided.
                    unsafe { CStr::from_ptr(cstr.cast()) }.to_bytes(),
                ))
            });

            builder.set_debug_dirs(Some(iter))
        }

        #[cfg(not(feature = ""dwarf""))]
        {
            builder
        }
    };

    let symbolizer = builder.build();
    let symbolizer_box = Box::new(symbolizer);
    let () = set_last_err(blaze_err::OK);
    Box::into_raw(symbolizer_box)
}",46,"(742, 797)"
