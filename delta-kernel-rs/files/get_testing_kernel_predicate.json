[
    {
        "function_name": "get_testing_kernel_predicate",
        "file_name": "E:\\rust_projects\\c\\delta-kernel-rs\\ffi\\examples\\visit-expression\\visit_expression.c",
        "commit_count": 0,
        "commits": []
    },
    {
        "function_name": "get_testing_kernel_predicate",
        "file_name": "E:\\rust_projects\\c\\delta-kernel-rs\\ffi\\src\\test_ffi.rs",
        "commit_count": 2,
        "commits": [
            {
                "commit_info": "2315d00bece42ca78a5ee314d80d69f0bc7407be",
                "commit_title": "feat!: Split out predicates as different from expressions (#775)\n\n## What changes are proposed in this pull request?\n\nTeach kernel to treat \"predicates\" (boolean-valued invertible\nexpressions) as different from normal expressions (which are generally\nneither boolean-valued nor invertible). Accomplished by splitting out a\nnew `Predicate` type from today's `Expression` type, and then adjusting\nall the various transforms, visitors, and evaluation frameworks\naccordingly.\n\nThis change is highly invasive, but very important because kernel's data\nskipping cares very much about predicates (= expressions that return\nboolean values and are invertible), which are quite different from the\nordinary expressions used for transforming data. We see that tension\nalready in the fact that some of our binary operators are really\n(invertible) binary predicates (`=`, `DISTINCT`, etc.), while others are\nnot (e.g. `+`, `-`). Further, a key piece of our predicate evaluation is\nthe ability to push NOT through an invertible expression. Pushing down\nNOT is more than just a performance optimization -- it is required for\ncorrect stats-based data skipping because `NOT\nskipping_predicate(<expr>)` is NOT equivalent to `skipping_predicate(NOT\n<expr>)`.\n\nThe work has been carefully split into a number of commits, each\nfocusing on a different change. Most of the changes are preparatory work\nintended to gradually increase the amount of predicate awareness in the\ncode, while reducing the churn of the final diff.\n\nCloses https://github.com/delta-io/delta-kernel-rs/issues/765\n\n### This PR affects the following public APIs\n\nEverything related to expressions.\n\n## How was this change tested?\n\nAdded new unit tests and updated existing ones",
                "commit_date": "Wed May 7 14:18:56 2025 -0600",
                "added_functions": [
                    "pub unsafe extern \"C\" fn get_testing_kernel_predicate() -> Handle<SharedPredicate> {"
                ],
                "renamed": {
                    "check": "None",
                    "old_name": "new",
                    "new_name": "get_testing_kernel_predicate"
                }
            },
            {
                "commit_info": "5e5c299a0cd748536d4d70fa9f88fb5b4b877bb6",
                "commit_title": "Add visitor for converting kernel expressions to engine expressions (#363)\n\n## Rationale for the change\nEngines may need to apply expressions that originate in the kernel. This\ncan include filter predicates such as filters for protocol and metadata\nactions in a log file. Another example is logical to physical\ntransformations that the engine must apply, for instance to materialize\npartition columns. This PR introduces a visitor framework for kernel\nexpressions to be converted to engine expressions so that engines can\napply their own evaluators, predicate pushdowns, and optimizations on\nthese expressions.\n\nCloses: #358\n## What changes are included in this PR?\n5 major changes are made in this PR:\n1) A new module `ffi/src/expressions/kernel.rs` is added. This module is\nresponsible for converting kernel `Expression`s to the engine's\nrepresentation of expressions through an ffi-compatible visitor. The\nvisitor supports binary operations, scalars, struct expressions,\nvariadic and unary operators, and columns. All the engine has to do is\nimplement an `EngineExpressionVisitor` to support the conversion.\n2) The `EnginePredicate` to kernel `Expression`visitor code is moved to\n`ffi/src/expressions/engine.rs`. This is done to keep all ffi expression\ncode under the `ffi/src/expressions` module.\n3) This PR also allows engines to get `SharedExpression`s, which are\nhandles to the kernel's `Expression` type. These are given back to the\nkernel to specify which expression the engine would like to visit.\n4) A new ffi example is added to showcase how the\n`EngineExpressionVisitor` can be used to construct expressions. This is\na C implementation that can be found in\n`ffi/examples/visit-expression/`. The example only prints an expression\nthat it receives from the kernel and asserts that it matches an expected\noutput.\n5) A new testing feature flag `test-ffi` is added to the `ffi` crate.\nThis feature flag is used to expose testing functions found in\n`ffi/src/test_ffi`. This module is currently used to return a kernel\nexpression `get_testing_kernel_expression` used in the example c\nimplementation.\n<!-- Mention all the new apis for the visitor. How they work (ex:\nSchema) -->\n## Are these changes tested?\nTwo tests are added:\n- I introduced a new test to validate the expression visitor functions\ncorrectly and converts data as expected. This simply prints out the\nexpression tree structure and compares it to an expected result. The\nkernel expression can be found in `ffi/src/test_ffi.rs`, and the\nexpected output is in `ffi/tests/test-expression-visitor/expected.txt`\n- There is also a test that checks for memory leaks in the expression\nvisitor using valgrind.\n\n## Are there any user-facing changes?\nThis PR introduces a public facing API for constructing expressions and\nvisiting them. It also adds `delta_kernel_derive` as a public export of\n`kernel` crate. This PR does not break existing APIs.",
                "commit_date": "Mon Oct 28 12:39:16 2024 -0700",
                "added_functions": [
                    "Arc::new(Expr::and_from(sub_exprs)).into()\n}"
                ]
            }
        ]
    }
]